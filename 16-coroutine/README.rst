======================================================================
Sample code for Chapter 16 - "Coroutines"
======================================================================

From the book "Fluent Python" by Luciano Ramalho (O'Reilly, 2015)
http://shop.oreilly.com/product/0636920032519.do

ここは読むかどうか悩む。
Coroutine 周りは仕様が激しく動くので、数年前のふつうのコードが時代遅れになっている可能性が高い。

coro_exec_demo.py
======================================================================

``demo_exc_handling()`` という自称 coroutine の振る舞いを実演する。

* ``demo_exc_handling()``

  * 無限ループの中で何かをするというのが基本構造だ。
  * ``x = yield`` という構文がえらく特徴的だ。
    これは呼び出し側の ``send()`` と結びついているはずだ。
    値を受けとり単に ``print()`` する。
  * ``try`` ブロックで処理する例外は呼び出し側からもたらされることを前提にしている。
    この例では単に握りつぶすだけだが、もしそうしなければ、
    あるいは再送出すれば coroutine 呼び出し側へ伝わる？

* 呼び出し側

  * まず戻り値を一時変数に割り当てる。それに対して即 ``next()`` を呼び出す。
  * ``.send()`` で coroutine を「活性化」できる？
  * ``.throw()`` で coroutine に例外を送出できる。
  * ``.close()`` で coroutine を停止できる。
  * ``inspect.getgeneratorstate()`` で coroutine の Python 的状態を得られる。

coro_finally_demo.py
======================================================================

coro_exec_demo.py の ``demo_exc_handling()`` の ``try`` ブロックに
``finally`` 節を追加した。これにより呼び出し側の ``.close()`` に応答できる。

coroaverager*.py
======================================================================

以前やった算術平均計算。

* 0.py のはいかにも初版という感じだ。明らかに洗練されていない。
* 1.py で後述の ``coroutil.coroutine`` を導入。手動 ``next()`` が不要になった。
* 2.py では ``None`` を受け取ると無限ループを抜けて ``return`` するように変更。
  こうすることで ``StopIteration`` の送出を引き起こす。
  呼び出し側がこれを処理することになった。
* 3.py の見どころは ``grouper()`` の ``yield from averager()`` 辺り。

  * コードが読みにくいのが難だ。
  * 著者は ``grouper()`` と ``averager()`` をそれぞれ
    委譲ジェネレーター、サブジェネレーターと称している。
    ``main()`` が直接呼び出すのは前者だ。
  * ``yield from ...`` は ``send()`` を溜め込んでおける？
    あとで言語仕様を確認したい。

coroutil.py
======================================================================

デコレーター関数 ``coroutine()`` の定義だけ。

* ``@functools.wraps()`` で docstring を確か引っ越せる。
* デコレーターの機能としては、与えられた関数の戻り値を ``next()`` して返すだけだから、
  ジェネレーターのためのデコレーターということになる。

このモジュールは coroaverager*.py のいずれかが import する。

taxi_sim*.py
======================================================================

これは実用性が増していて面白い。

* text_sim0.py の末尾にドキュメントあり。

* ``add_argument()`` の ``default`` 値をコード内の定数で指定する手口は真似したい。
* 乱数が絡むコードは ``random.seed()`` の引数を指定可能であるようにする。再現可能目的。
* ``text_process()`` が ``yield Event()`` の形で generator を返す。

  * この generator はもしかしたら State パターンかもしれない。

* タクシー一台が ``Event`` を列の形で持つ。

  "leave garage", ("pick up", "drop off")+, "going home"

  という持ち方。

* ``Event`` はたんなる構造体データと捉える。
* ``Simulator`` はタクシーの collection を受け取って ``run()`` する。

  * ``queue.PriorityQueue`` の実演コードだとこれでわかる。
    ``.put()``, ``.empty()``, ``get()``, ``qsize()`` の使い方がわかる。

    * ``.qsize()`` は組み込み ``len()`` とは違うのか？

  * ``next()`` がイヤな感じがする。
  * ループがわかりにくい。キューでループするわけではないとは。

* ``compute_duration()`` で状態遷移をする。
  ``int(random.expovariate())`` がミソ？

yield_from_expansion*.py
======================================================================

``yield from`` 構文の説明。

以上
