======================================================================
Sample code for Chapter 16 - "Coroutines"
======================================================================

From the book "Fluent Python" by Luciano Ramalho (O'Reilly, 2015)
http://shop.oreilly.com/product/0636920032519.do

ここは読むかどうか悩む。
Coroutine 周りは仕様が激しく動くので、数年前のふつうのコードが時代遅れになっている可能性が高い。

coro_exec_demo.py
======================================================================

``demo_exc_handling()`` という自称 coroutine の振る舞いを実演する。

* ``demo_exc_handling()``

  * 無限ループの中で何かをするというのが基本構造だ。
  * ``x = yield`` という構文がえらく特徴的だ。
    これは呼び出し側の ``send()`` と結びついているはずだ。
    値を受けとり単に ``print()`` する。
  * ``try`` ブロックで処理する例外は呼び出し側からもたらされることを前提にしている。
    この例では単に握りつぶすだけだが、もしそうしなければ、
    あるいは再送出すれば coroutine 呼び出し側へ伝わる？

* 呼び出し側

  * まず戻り値を一時変数に割り当てる。それに対して即 ``next()`` を呼び出す。
  * ``.send()`` で coroutine を「活性化」できる？
  * ``.throw()`` で coroutine に例外を送出できる。
  * ``.close()`` で coroutine を停止できる。
  * ``insepect.getgeneratorstate()`` で coroutine の Python 的状態を得られる。

coro_finally_demo.py
======================================================================

coro_exec_demo.py の ``demo_exc_handling()`` の ``try`` ブロックに
``finally`` 節を追加した。これにより呼び出し側の ``.close()`` に応答できる。

coroaverager*.py
======================================================================

TBW

coroutil.py
======================================================================

デコレーター関数 ``coroutine()`` の定義だけ。

* ``@functools.wraps()`` で docstring を確か引っ越せる。
* デコレーターの機能としては、与えられた関数の戻り値を ``next()`` して返すだけだから、
  ジェネレーターのためのデコレーターということになる。

このモジュールは coroaverager*.py のいずれかが import する。

taxi_sim*.py
======================================================================

TBW

yield_from_expansion*.py
======================================================================

TBW

以上
