======================================================================
Sample code for Chapter 18 - "Concurrency with asyncio"
======================================================================

From the book "Fluent Python" by Luciano Ramalho (O'Reilly, 2015)
http://shop.oreilly.com/product/0636920032519.do

##################################################################
NOTE: this "18b" directory contains the examples of chapter 18
rewritten using the new async/await syntax available in Python 3.5
ONLY, instead of the "yield-from" syntax which works since Python
3.3 (and will still work with Python 3.5).
##################################################################

charfinder/
======================================================================

サードパーティー製パッケージ aiohttp, テストもするなら pytest が必要。

* charfinder.py: 基本形モジュール。Unicode 文字を見つけるツール。
  例えば ``'rook'`` を与えると U+2656, U+265C が返る。

* tcp_charfinder.py: 強化版。

  * ``asyncio.start_server()`` はソケットサーバーを開始するらしい。
    戻り値は awaitable なので ``.run()`` にこの後渡す。

    最初の引数は ``asyncio.StreamReader`` と ``asyncio.StreamWriter`` を引数に取る関数だ。
    これらについては後で調べる。残りの引数はサーバー生成関数のためのものだ。

  * サーバーを開始するのに ``.run()`` するのだが、
    実引数と戻り値の関係性がわからない。前者は以後一切参照されなくなる。

  * ここでサーバーを終了するに ``.close()`` を呼び出してから
    ``.wait_closed()`` で待機する方式を採っている。
    これは前者が非同期的に停止する機能であるため、
    プログラム全体を終了する前にサーバーの停止を待機したいからだ。

  * サーバーの処理を ``handle_queries()`` で実装。基本的に無限ループ。
    ``await`` による同期待ちが次の 2 ケースある：

    * ``await writer.drain()``: 標準出力に書き込みができる状態になるまで待機する。
    * ``await reader.readline()``: バイト列を「一行」標準入力から読み取る。

* test_charfinder.py: よくあるテストコード。18 passed するはず。

countdown.py
======================================================================

この実演コードは 4 タスクを concurrently に実行する。各タスクは標準出力にテキストを出力する。

.. code:: console

   bash$ ./countdown.py
   ──────────────────────────────────────────────────
    0.3042s                 C = 3
   ──────────────────────────────────────────────────
    0.6051s                 C = 2
   ──────────────────────────────────────────────────
    0.7127s A = 3
   ──────────────────────────────────────────────────
    0.9037s                 C = 1
   ──────────────────────────────────────────────────
    1.0141s                         D = 3
   ──────────────────────────────────────────────────
    1.4022s A = 2
   ──────────────────────────────────────────────────
    2.0129s         B = 3
   ──────────────────────────────────────────────────
    2.0129s                         D = 2
   ──────────────────────────────────────────────────
    2.1038s A = 1
   ──────────────────────────────────────────────────
    3.0113s                         D = 1
   ──────────────────────────────────────────────────
    4.0128s         B = 2
   ──────────────────────────────────────────────────
    6.0172s         B = 1
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

* ユーザー関数 ``countdown()`` をタスクの素とする。
* ``asyncio.sleep()`` は指定時間フリーズというよりは待機という意味にとったほうが
  マルチスレッドプログラムとの類比がしやすく理解できる。
* 統括側では ``asyncio.wait()`` により複数タスクを一斉に開始する。
  ユーザー関数を ``Task`` で wrap するのに ``create_task()`` を用いる。
  これにより生成されたタスクは即時に開始する。
* 本プログラムにはメインスレッドに相当する部分が存在しない。

* 本題以外のみどころ

  * ``time.perf_counter()`` でどの場所からも共通する「時刻」を参照できる。

spinner*.py
======================================================================

長時間処理中に画面に風車を描く実演コードだ。
これらのコードは基本的なので必ず習得するように。

.. code:: shell

   bash$ ./spinner_thread.py
   spinner object: <Thread(Thread-1, initial)>
   Answer: 42
   bash$ ./spinner_asyncio.py
   spinner object: <Task pending coro=<spin() running at ./spinner_asyncio.py:14>>
   Answer: 42

両者の差分を調べればマルチスレッド化・非同期化の方法がわかる？

* spinner_thread.py: ``Thread`` オブジェクトの対象をユーザー関数 ``spin()`` に指定して
  ``Event`` オブジェクトと共にスレッド ``spinner`` を定義する。

  * 風車側がスレッドである。
  * ``spinner.start()`` でユーザー側を開始する。メインスレッドも進行する。
  * メイン側は ``slow_function()`` でもたつくようにする。
    そのあとに ``Event`` オブジェクトの ``.set()`` をする。
    これにより当イベントの終了を待機しているものがもしれば、それを「起こす」ことになる。
    ただちに ``spinner.join()`` を呼び出す。これで終了まで待機する。
  * ユーザー関数 ``spin()`` は 0.1 秒ごとにコンソールに一文字を巡回的に同じ桁に出力し続ける。
    ``Event`` オブジェクトの ``.wait()`` で指定時間待機するが、もし終了していればループを抜ける。

* spinner_asyncio.py:

  * 風車側もメイン側も awaitable な関数として定義する。それらを統括する関数も awaitable だ。
  * マルチスレッド版コードで ``spinner`` と呼んでいたものはここでは ``Task`` になる。
    したがって即時に ``spin()`` 側が開始する。これはマルチスレッド版と対照的だ。
  * メイン側 ``slow_function()`` を ``await`` する。
    例外が送出されない限りは終了までブロックする。
    終了後はタスクを ``.cancel()`` することで対応する例外を送出させる。
  * ユーザー関数 ``spin()`` の目的はマルチスレッド版と同じ。違いは

    * 自身が awaitable 関数である。
    * 待機方法が ``asyncio.sleep()`` による。共有オブジェクトの状態参照ではないという意味にとりたい。
      待機終了の判定方法も戻り値の判定ではなく例外捕捉によるものに変わる。

本題以外の見どころ：

* ``itertools.cycle()`` つまり巡回置換で「スピン」を表現する。
* 標準出力における ``'\r'`` の使い方。

以上
