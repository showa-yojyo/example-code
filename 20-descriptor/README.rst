======================================================================
Sample code for Chapter 20 - "Attribute descriptors"
======================================================================

From the book "Fluent Python" by Luciano Ramalho (O'Reilly, 2015)
http://shop.oreilly.com/product/0636920032519.do

Descriptor
======================================================================

Descriptor とは ``__get__()``, ``__set__()``, ``__delete__()`` のいずれかを
持つ（クラスの）オブジェクトである。

オブジェクト ``obj`` に対する ``obj.x`` の意味はおおまかに言えば次の順に解釈される。
多重継承や抽象基底を持つ場合にはこれより少し複雑になる：

* ``obj.__dict__['x']``
* ``obj.__class__.__dict__['x']``
* ``obj.__class__`` の super class の ``.__dict__['x']__``
* ``obj.__class__`` により近い基底のクラスの順に ``.__dict__['x']__``

``__get__()`` と ``__set__()`` の両方を持つオブジェクトは
**data descriptor** であるという。
``__get__()`` を持ち ``__set__()`` を持たないオブジェクトは
**non-data descriptor** であるという。

これを利用して read-only な data descriptor を定義できることに注意する。
``__get__()`` と ``__set__()`` をオーバーライドして後者で例えば
``AttributeError`` を送出すればよい。

オブジェクトに対する ``__get__()`` とクラスに対するそれとでも、辞書の参照優先順位が異なる。

bulkfood/
======================================================================

bulkfood 系
----------------------------------------------------------------------

* bulkfood_v3.py: v2 の修正ファイル。関数 ``quantity()`` をクラス
  ``Quantity`` に作り変えた。

  * その結果 get がなくなり、``__init__()`` を代わりに書く必要がある。
  * ``LineItem`` の ``weight``, ``price`` が？になる。

* bulkfood_v4.py: v3 の修正ファイル

  * ``Quantity`` の ``storage_name`` を自動的に決まるように
    クラス変数 ``__counter`` を持つようにする。

* bulkfood_v4b.py: v4 の修正ファイル

  * ``Quantity`` の ``__get__()`` を修正。
    ``instance`` がなければ ``self`` を返す。
    これはオブジェクトではなくクラス経由で ``Quantity`` にアクセスされる場合を気にしたコードだ。

* bulkfood_v4c.py: v4 の修正ファイル

  * ``Quantity`` を外モジュールから import するように修正。

* bulkfood_v4prop.py: v4 の修正ファイル。
  クラス ``Quantity`` を関数 ``quantity`` として実装。

  * このように関数が独自の変数を保持できることは覚えておく。
    関数内部からそれにアクセスするコードは、クラスのメソッドがクラス変数にアクセスするようなものだ。

* bulkfood_v5.py: ``LineItem`` の ``description`` にも手を入れる。
  ``NonBlank`` という型のオブジェクトとなる。後述。

* bulkfood_v5_check.py: ``LineItem`` のすべてのメンバーデータを
  ``Check`` オブジェクトとする。後述。

model 系
----------------------------------------------------------------------

このコードを見て関連実演コード群の意図がわかった。

* model_v4c.py: クラス ``Quantity``

  * ``__counter`` は前述のとおり。
  * 書き忘れたがメソッド中では ``self.__class__`` でクラス自体にアクセスできる。
    そのオブジェクトを通じて ``.__name__`` を参照するとクラス名が ``str`` オブジェクトとして得られる。
  * ``__get__()`` についての注意点は上に述べた。

* model_v5.py: クラス詰め合わせ。ここはしっかり見ていく。

  * クラス ``AutoStorage`` は旧 ``Quantity`` と同様。``__set__()`` だけ汎用コードに置き換えた。

    * その ``__set__()`` は関数 ``setattr()`` 呼び出しで実装。
      ``x.y = v`` のようなことをするために ``setattr(x, 'y', v)`` とする。

  * クラス ``Validated`` は ``AutoStorage`` のサブクラスとする。

    * 抽象クラスとするため ``abc.ABC`` も継承する。これで
      ``@abstractmethod`` が使える。
    * 抽象メソッド ``validate()`` を宣言だけする。中身は docstring のみ。
    * 重要なのは ``validate()`` の呼び出しを ``__set__()`` で行うところだ。
      値が妥当であるときに限り ``super().__set__()`` すなわち
      ``AutoStorage`` の既定の処理を呼び出す。

  * リメイク版クラス ``Quantity`` は ``Validated`` のサブクラスとする。
    メソッド ``validate()`` をオーバーライドする。中身は前述のとおり。

  * クラス ``NonBlank`` は ``Validated`` のサブクラスとする。
    メソッド ``validate()`` の中身は与えられた ``str`` オブジェクトが空でないことをテストするというものだ。

* model_v5_check.py: ``Validated`` のサブクラスは一つでいい。

  * クラス ``Check`` を ``Validated`` のサブクラスとする。
    引数 ``checker`` は関数とする。

    * メソッド ``validate()`` でその関数 ``checker()`` を呼び出す。
      これが失敗したら例外を送出する。

  * ``object()`` は癖が強いと思う。

descriptorkinds*.py
======================================================================

``__get__()`` と ``__set__()`` を両方または片方オーバーライドする実演。
そしてメンバーへのアクセスはオブジェクト経由かクラス経由かで異なるものであることを見る。

* 左辺値としての ``obj.over``, ``Manager.over``, ``obj.__dict__['over']`` の違いを見る。
* ``vars(obj)`` により ``obj`` のメンバーデータを ``dict`` として得られる。

* ``__get__()`` をオーバーライドしない場合

  * ``obj.over_no_get`` と ``Model.over_no_get`` は同じになる。
  * ``obj.__dict__`` 経由で値をオブジェクトの属性としてセットできる。

* ``__get__()`` をオーバーライドする場合

  * ``obj.non_over = 7`` としてから ``Model.non_over`` を右辺値参照しても `7` は得られない。
  * ``del`` によりセットした値を消せる。セットする前の状態に戻る。

* メソッドはそういうことにならない。オブジェクトごしに値を代入するとメソッドが隠れる。

method_is_descriptor.py
======================================================================

Python の ``str`` は immutable なので ``reverse()`` のようなメソッドは当然ない。

* ``collections.UserString`` 文字列クラスを書くときに継承する。
  ``__init__()``, ``__getitem__()``, ``__len__()`` をオーバーライドする。
* ``self.data`` で文字列本体を参照する。
* メソッド名は ``reversed()`` のほうが Python に親和的でいいと思う。

以上
